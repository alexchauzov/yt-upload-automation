# Анализ спорных мест архитектуры

## Критические проблемы

### 1. Ошибка инициализации YouTubeApiBackend

**Местоположение:** `app/main.py:69`

**Проблема:**
```python
video_backend = YouTubeApiBackend()  # ❌ Не передается media_file_store
```

Конструктор `YouTubeApiBackend.__init__()` требует обязательный параметр `media_file_store: MediaFileStore`, но в `app/main.py` он создается без параметров. Это приведет к `TypeError` при запуске.

**Решение:**
```python
video_backend = YouTubeApiBackend(media_file_store=media_file_store)
```

---

### 2. Нарушение Clean Architecture: зависимость адаптера от адаптера

**Местоположение:** `adapters/youtube_backend.py:41`

**Проблема:**
`YouTubeApiBackend` (адаптер) зависит от `MediaFileStore` (другой адаптер). Это нарушает принцип изоляции слоев - адаптеры не должны зависеть друг от друга напрямую.

**Архитектурная проблема:**
- Адаптеры должны реализовывать порты, но не зависеть от других адаптеров
- Это создает жесткую связь между двумя реализациями
- Усложняет тестирование и замену компонентов

**Альтернативные решения:**
1. **Передавать уже разрешенный путь:** `VideoBackend.publish_video()` должен принимать `Path`, а не `str`, и разрешение пути делать в domain-слое
2. **Убрать зависимость:** `YouTubeApiBackend` не должен знать о `MediaFileStore` - путь должен разрешаться до вызова

---

### 3. Несоответствие интерфейса и реализации

**Местоположение:** `ports/video_backend.py:15` vs `adapters/youtube_backend.py:157`

**Проблема:**
- Интерфейс `VideoBackend.publish_video(task, media_ref: str)` принимает строку
- Реализация `YouTubeApiBackend.publish_video()` внутри вызывает `self.media_file_store.get_path(media_ref)`
- Это означает, что интерфейс неполный - он не отражает реальные требования реализации

**Последствия:**
- Нельзя использовать `VideoBackend` без `MediaFileStore`
- Нарушается контракт интерфейса
- Другие реализации `VideoBackend` вынуждены либо тоже зависеть от `MediaFileStore`, либо игнорировать эту зависимость

---

### 4. Несоответствие типов: Optional VideoBackend

**Местоположение:** `domain/services.py:32` vs `app/main.py:64`

**Проблема:**
- В `PublishService.__init__()` параметр `video_backend: VideoBackend` не Optional
- В `app/main.py` в dry-run режиме передается `None`
- В коде есть проверки `if self.dry_run`, но тип не отражает возможность `None`

**Последствия:**
- Type checkers (mypy, pyright) будут ругаться
- Риск `AttributeError` при обращении к `self.video_backend` без проверки

**Решение:**
```python
video_backend: VideoBackend | None = None
```
И добавить проверки везде, где используется.

---

### 5. Дублирование ответственности за работу с файлами

**Местоположение:** `domain/services.py` и `adapters/youtube_backend.py`

**Проблема:**
- `PublishService` использует `media_file_store` для валидации и transition
- `YouTubeApiBackend` тоже использует `media_file_store` для разрешения путей
- Это создает две точки, где один и тот же адаптер используется для разных целей

**Архитектурный вопрос:**
Кто должен отвечать за разрешение `media_ref` в абсолютный путь?
- Domain-слой (PublishService) - тогда передавать `Path` в `VideoBackend`
- Adapter-слой (YouTubeApiBackend) - тогда нужна зависимость от `MediaFileStore`

Текущее решение (adapter разрешает) нарушает изоляцию слоев.

---

### 6. Transition изменяет путь до загрузки

**Местоположение:** `domain/services.py:135-139`

**Проблема:**
```python
new_media_ref = self.media_file_store.transition(
    task.video_file_path, MediaStage.IN_PROGRESS
)
task.video_file_path = new_media_ref  # Путь изменен!
video_path = self.media_file_store.get_path(new_media_ref)
```

Файл перемещается в другую директорию ДО загрузки. Это означает:
- Если загрузка упадет, файл уже перемещен
- `task.video_file_path` изменяется, но это может не синхронизироваться с Google Sheets
- Сложно откатить изменения при ошибке

**Вопрос:** Должен ли transition происходить до или после успешной загрузки?

---

### 7. Отсутствие транзакционности операций

**Местоположение:** `domain/services.py:publish_task()`

**Проблема:**
Операции выполняются последовательно без отката:
1. Transition файла (необратимо)
2. Обновление статуса в Sheets
3. Загрузка на YouTube
4. Обновление статуса в Sheets

Если шаг 3 упадет, файл уже перемещен, статус может быть UPLOADING, но загрузка не выполнена.

**Последствия:**
- Неконсистентное состояние
- Сложно восстановить после сбоя
- Нет механизма компенсирующих действий

---

### 8. Смешение абстракций: media_ref vs file_path

**Местоположение:** Везде

**Проблема:**
- В интерфейсах используется термин `media_ref` (абстрактная ссылка)
- В реализации `LocalMediaFileStore` это просто файловый путь
- `YouTubeApiBackend` ожидает, что `media_ref` - это путь, который можно разрешить через `MediaFileStore`

**Неясность:**
- Что такое `media_ref`? Это путь? S3 key? URL? Идентификатор?
- Если это абстракция, почему `YouTubeApiBackend` знает, как его разрешать?
- Если это путь, зачем абстракция?

---

### 9. Жесткая связь с локальной файловой системой

**Местоположение:** `adapters/youtube_backend.py:157`

**Проблема:**
```python
video_path = self.media_file_store.get_path(media_ref)
# ...
media = MediaFileUpload(str(video_path), ...)
```

`MediaFileUpload` работает только с локальными файлами. Если в будущем понадобится загружать из S3/GCS напрямую, это не сработает.

**Ограничение:**
- Нельзя использовать streaming upload из облачного хранилища
- Всегда требуется локальная копия файла
- Неэффективно для больших файлов

---

### 10. Неявная зависимость от порядка инициализации

**Местоположение:** `app/main.py:create_publish_service()`

**Проблема:**
Порядок создания зависимостей важен:
1. Сначала `media_file_store` (нужен для `YouTubeApiBackend`)
2. Потом `metadata_repo` (независим)
3. Потом `video_backend` (зависит от `media_file_store`)

Если изменить порядок, код сломается. Нет явной декларации зависимостей.

**Решение:**
Использовать DI-контейнер или явно документировать зависимости.

---

## Средние проблемы

### 11. Отсутствие интерфейса для конфигурации

**Местоположение:** Везде

**Проблема:**
Конфигурация размазана по коду:
- Environment variables читаются в конструкторах адаптеров
- Нет единой точки конфигурации
- Сложно тестировать с разными конфигами

---

### 12. Обработка ошибок через исключения и возвращаемые значения

**Местоположение:** `domain/services.py` и `adapters/youtube_backend.py`

**Проблема:**
Смешаны два подхода:
- `PublishResult.success: bool` - результат через возвращаемое значение
- `RetryableError`, `PermanentError` - ошибки через исключения

Это создает путаницу: когда проверять `result.success`, а когда ловить исключения?

---

### 13. Логирование в domain-слое

**Местоположение:** `domain/services.py`

**Проблема:**
Domain-слой использует `logging`, что создает зависимость от стандартной библиотеки (это OK), но также создает side-effect - логирование влияет на поведение системы.

В чистой архитектуре domain не должен иметь side-effects кроме бизнес-логики.

---

### 14. Использование datetime.utcnow() напрямую

**Местоположение:** `adapters/google_sheets_repository.py`, `domain/services.py`

**Проблема:**
Прямое использование `datetime.utcnow()` усложняет тестирование (нельзя замокать время) и создает неявную зависимость от системного времени.

**Решение:**
Инжектировать time provider или использовать библиотеку типа `freezegun` в тестах.

---

## Мелкие замечания

### 15. Дублирование логики разрешения путей

`LocalMediaFileStore._resolve_path()` и использование в `YouTubeApiBackend` - похожая логика в разных местах.

### 16. Магические строки для статусов

Используются строковые литералы `"READY"`, `"UPLOADING"` в некоторых местах вместо `TaskStatus.READY.value`.

### 17. Отсутствие валидации на уровне портов

Порты не валидируют входные данные - вся валидация в адаптерах. Это может привести к разным правилам валидации в разных реализациях.

---

## Рекомендации по приоритетам

### Критично (исправить немедленно):
1. ✅ Ошибка инициализации `YouTubeApiBackend` - код не работает
2. ⚠️ Несоответствие типов `Optional VideoBackend` - может привести к runtime ошибкам

### Важно (исправить в ближайшее время):
3. Нарушение Clean Architecture (зависимость адаптера от адаптера)
4. Несоответствие интерфейса и реализации
5. Отсутствие транзакционности операций

### Желательно (рефакторинг):
6. Дублирование ответственности за работу с файлами
7. Смешение абстракций media_ref vs file_path
8. Жесткая связь с локальной ФС

### Можно отложить:
9-17. Остальные замечания
