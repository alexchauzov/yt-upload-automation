# Архитектура проекта

## Обзор

Проект построен на принципах **чистой архитектуры** (Clean Architecture) с чётким разделением на слои и контролем зависимостей.

## Слои приложения

### 1. Core (Ядро / Доменная логика)

**Расположение:** `src/core/`

**Ответственность:**
- Доменная логика приложения
- Бизнес-правила и валидация
- Модели данных (entities)
- Конфигурация приложения

**Правила зависимости:**
- ✅ Может зависеть от стандартной библиотеки Python
- ✅ Может зависеть от общих библиотек (pydantic, dataclasses)
- ✅ Может зависеть от других модулей внутри `core`
- ❌ **НЕ МОЖЕТ** зависеть от `adapters`
- ❌ **НЕ МОЖЕТ** зависеть от `cli`
- ❌ **НЕ МОЖЕТ** зависеть от конкретных внешних API

**Примеры компонентов:**
- `config.py` — управление конфигурацией
- `models.py` — доменные модели (Video, UploadRequest и т.п.)
- `validators.py` — валидация данных
- `exceptions.py` — доменные исключения

### 2. Adapters (Адаптеры)

**Расположение:** `src/adapters/`

**Ответственность:**
- Взаимодействие с внешними сервисами и API
- Преобразование данных между внешним форматом и доменными моделями
- Обработка технических деталей протоколов (HTTP, OAuth и т.п.)

**Правила зависимости:**
- ✅ Может зависеть от `core` — использует доменные модели
- ✅ Может зависеть от библиотек внешних API (google-api-python-client и т.п.)
- ✅ Может зависеть от других адаптеров (при необходимости)
- ❌ **НЕ ДОЛЖЕН** содержать бизнес-логику (она в `core`)

**Примеры адаптеров:**
- `adapters/youtube/` — работа с YouTube Data API v3
  - `client.py` — обёртка над API клиентом
  - `auth.py` — OAuth аутентификация
  - `uploader.py` — загрузка видео

### 3. CLI (Command Line Interface)

**Расположение:** `src/cli/`

**Ответственность:**
- Точки входа в приложение
- Парсинг аргументов командной строки
- Форматирование вывода для пользователя
- Оркестрация вызовов `core` и `adapters`

**Правила зависимости:**
- ✅ Может зависеть от `core`
- ✅ Может зависеть от `adapters`
- ✅ Может использовать CLI-библиотеки (argparse, click и т.п.)

**Примеры компонентов:**
- `auth.py` — команда аутентификации
- `upload.py` — команда загрузки видео
- `batch_upload.py` — пакетная загрузка

## Граф зависимостей

```
┌─────────────┐
│     CLI     │
└──────┬──────┘
       │
       ├───────────┐
       │           │
       ▼           ▼
┌──────────┐  ┌──────────┐
│   Core   │◄─│ Adapters │
└──────────┘  └──────────┘
```

**Направление зависимостей:**
- CLI → Core
- CLI → Adapters
- Adapters → Core
- Core → (только стандартные библиотеки)

## Преимущества такой архитектуры

1. **Тестируемость:** Доменная логика в `core` тестируется без внешних зависимостей
2. **Гибкость:** Легко заменить YouTube API на другой сервис — достаточно написать новый адаптер
3. **Понятность:** Чёткое разделение ответственности между слоями
4. **Независимость:** Бизнес-логика не зависит от деталей реализации внешних API

## Правила разработки

### ✅ DO (Делай)

- Держи `core` максимально независимым
- Используй интерфейсы (протоколы) для связи между слоями
- Пиши юнит-тесты для `core` без моков внешних API
- Размещай бизнес-логику в `core`, а технические детали в `adapters`

### ❌ DON'T (Не делай)

- Не импортируй `adapters` в `core`
- Не размещай бизнес-логику в `adapters` или `cli`
- Не создавай циклические зависимости между слоями
- Не обращайся напрямую к внешним API из `core` или `cli`

## Пример потока данных

Загрузка видео на YouTube:

1. **CLI** (`cli/upload.py`)
   - Парсит аргументы командной строки
   - Создаёт доменную модель `UploadRequest` из `core`

2. **Core** (`core/validators.py`)
   - Валидирует данные запроса
   - Применяет бизнес-правила

3. **Adapter** (`adapters/youtube/uploader.py`)
   - Преобразует доменную модель в формат YouTube API
   - Выполняет HTTP-запрос к API
   - Преобразует ответ обратно в доменную модель

4. **CLI** (`cli/upload.py`)
   - Получает результат
   - Форматирует и выводит сообщение пользователю

## Расширение функциональности

При добавлении новых возможностей:

1. Определи доменную модель в `core`
2. Реализуй адаптер в `adapters` (если нужна работа с внешним API)
3. Создай CLI-команду в `cli` для взаимодействия с пользователем

Следуя этой последовательности, архитектура остаётся чистой и поддерживаемой.
